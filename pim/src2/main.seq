#include <alloc.h>
#include <barrier.h>
#include <defs.h>
#include <mram.h>
#include <mutex.h>
#include <perfcounter.h>

#include <stdint.h>
#include <string.h>
#include "request.h"
#include "seqread.h"

#ifdef TRACE
STDOUT_BUFFER_INIT(256);
#endif

#define WCACHE_SIZE 256

BARRIER_INIT(barrier, NR_TASKLETS);
MUTEX_INIT(mutex_responses);

__host algo_request_t DPU_REQUEST_VAR;
__host algo_stats_t DPU_STATS_VAR;

seqreader_buffer_t cache1[NR_TASKLETS], cache2[NR_TASKLETS];
seqreader_t sr1[NR_TASKLETS], sr2[NR_TASKLETS];
tuple_t wcache[NR_TASKLETS][WCACHE_SIZE];
uint32_t wcache_index[NR_TASKLETS];

uintptr_t data_begin = (uintptr_t)DPU_MRAM_HEAP_POINTER;
uintptr_t tmp_begin = (uintptr_t)DPU_MRAM_HEAP_POINTER + MRAM_SIZE + MRAM_SIZE;

void flush_cache(uint8_t tid, __mram_ptr tuple_t *wmem, uint32_t * dst_index) {

    mram_write(wcache[tid], &wmem[*dst_index], sizeof(tuple_t) * (wcache_index[tid] + 1));
    wcache_index[tid] = 0;
    *dst_index += wcache_index[tid] + 1;
}

void cache_write(uint8_t tid, const tuple_t * tp, 
		__mram_ptr tuple_t *wmem, uint32_t * dst_index) {

    // if cache size is reached, write into mram first
    if(wcache_index[tid] + 1 == WCACHE_SIZE) {
	flush_cache(tid, wmem, dst_index);
    }

    wcache[tid][wcache_index[tid]++] = *tp;
}

void merge(__mram_ptr tuple_t *a, uint32_t left, uint32_t mid, uint32_t right, __mram_ptr tuple_t *tmp) {
    uint32_t i = left;
    uint32_t j = mid;
    uint32_t k = left;

    // initialize the sequential readers to read from address in MRAM
    uint8_t *curr_char1 = seqread_seek(&a[left], &sr1[me()]);
    uint8_t *curr_char2 = seqread_seek(&a[mid], &sr2[me()]);

    while (i < mid && j < right) {
        __dma_aligned tuple_t ai, aj;
        //mram_read(&a[i], &ai, sizeof(tuple_t));
        //mram_read(&a[j], &aj, sizeof(tuple_t));
	ai = *((tuple_t*)curr_char1);
	aj = *((tuple_t*)curr_char2);
        if (ai.key < aj.key) {
            //mram_write(&ai, &tmp[k], sizeof(tuple_t));
            //k++;
            cache_write(me(), &ai, tmp, &k);
            i++;
	    curr_char1 = seqread_get(curr_char1, sizeof(tuple_t), &sr1[me()]);
        } else {
            //mram_write(&aj, &tmp[k], sizeof(tuple_t));
            cache_write(me(), &aj, tmp, &k);
            //k++;
            j++;
	    curr_char2 = seqread_get(curr_char2, sizeof(tuple_t), &sr2[me()]);
        }
    }

    while (i < mid) {
        tuple_t ai;
        //mram_read(&a[i], &ai, sizeof(tuple_t));
	curr_char1 = seqread_get(curr_char1, sizeof(tuple_t), &sr1[me()]);
	ai = *((tuple_t*)curr_char1);
        //mram_write(&ai, &tmp[k], sizeof(tuple_t));
	cache_write(me(), &ai, tmp, &k);
        //k++;
        i++;
    }

    while (j < right) {
        tuple_t aj;
        //mram_read(&a[j], &aj, sizeof(tuple_t));
	curr_char2 = seqread_get(curr_char2, sizeof(tuple_t), &sr2[me()]);
	aj = *((tuple_t*)curr_char2);
        //mram_write(&aj, &tmp[k], sizeof(tuple_t));
	cache_write(me(), &aj, tmp, &k);
        //k++;
        j++;
    }

    flush_cache(me(), tmp, &k);

//  memcpy(a + left, tmp + left, sizeof(tuple_t) * (right - left));
}

void merge_sort(__mram_ptr tuple_t *a, uint32_t len, __mram_ptr tuple_t *tmp) {
    if (len <= 1)
        return;

    uint32_t toggle = 0;
    __mram_ptr tuple_t *src, *dst;
    for (uint32_t width = 1; width < len; width <<= 1) {
        if (toggle & 1) {
            src = tmp;
            dst = a;
        }
        else {
            src = a;
            dst = tmp;
        }
        //clock_t t = clock();
        for (uint32_t i = 0; i < len; i += (width << 1)) {
            uint32_t mid = i + width;
            if (mid > len)
                mid = len;

            uint32_t right = mid + width;
            if (right > len)
                right = len;

            merge(src, i, mid, right, dst);
        }
        //t = clock() - t;
        //printf("width: %d, time: %f ms\n", width, (float)t * 1000 / CLOCKS_PER_SEC);
        toggle++;
    }

    if (toggle & 1)
        memcpy(a, tmp, len * sizeof(tuple_t));
}

uint32_t merge_join(__mram_ptr tuple_t *r, __mram_ptr tuple_t *s, uint32_t num_r, uint32_t num_s) {//, void *output) {
    uint32_t i = 0, j = 0, matches = 0;

    while (i < num_r && j < num_s) {
        tuple_t ai, aj;
        mram_read(&r[i], &ai, sizeof(tuple_t));
        mram_read(&s[j], &aj, sizeof(tuple_t));
        if (ai.key < aj.key)
            i++;
        else if (ai.key > aj.key)
            j++;
        else {
            matches++;
            j++;
        }
    }

    return matches;
}

int main()
{
    if (me() == 0) {
        perfcounter_config(COUNT_CYCLES, true);
        mem_reset();
        memset(&DPU_STATS_VAR, 0, sizeof(DPU_STATS_VAR));
    }

    barrier_wait(&barrier);

    // allocate two sequential readers to read from MRAM in WRAM
    cache1[me()] = seqread_alloc();
    cache2[me()] = seqread_alloc();
    seqread_init(cache1[me()], 0, &sr1[me()]);
    seqread_init(cache2[me()], 0, &sr2[me()]);

    uintptr_t tmp_offset = me() * MRAM_SIZE_PER_TASKLET;
    uintptr_t data_offset = me() * MRAM_SIZE_PER_TASKLET << 1;
    uintptr_t r_data = data_begin + data_offset;
    uintptr_t s_data = r_data + MRAM_SIZE_PER_TASKLET;

    merge_sort((__mram_ptr void *)r_data, TUPLES_NUM_PER_TASKLET, (__mram_ptr void *)(tmp_begin + tmp_offset));
    merge_sort((__mram_ptr void *)s_data, TUPLES_NUM_PER_TASKLET, (__mram_ptr void *)(tmp_begin + tmp_offset));

    uint32_t matches = merge_join((__mram_ptr void *)r_data, (__mram_ptr void *)s_data, TUPLES_NUM_PER_TASKLET, TUPLES_NUM_PER_TASKLET);


    DPU_STATS_VAR.nb_results[me()] = matches;
    DPU_STATS_VAR.exec_time = perfcounter_get();

    return 0;
}
